"""
This type stub file was generated by pyright.
"""

import orjson as orjson
import json
from ccxt.base.types import BalanceAccount, Bool, CancellationRequest, ConstructorArgs, Currency, IndexType, Int, Market, MarketType, Num, Order, OrderRequest, OrderSide, OrderType, Str, Strings, Trade
from typing import Any, List

"""Base exchange class"""
__version__ = ...
__all__ = ['Exchange']
orjson = ...
class SafeJSONEncoder(json.JSONEncoder):
    def default(self, obj): # -> dict[str, str] | Any | str:
        ...
    


class Exchange:
    """Base exchange class"""
    id = ...
    name = ...
    countries = ...
    version = ...
    certified = ...
    pro = ...
    alias = ...
    enableRateLimit = ...
    rateLimit = ...
    timeout = ...
    asyncio_loop = ...
    aiohttp_proxy = ...
    ssl_context = ...
    trust_env = ...
    aiohttp_trust_env = ...
    requests_trust_env = ...
    session = ...
    tcp_connector = ...
    aiohttp_socks_connector = ...
    socks_proxy_sessions = ...
    verify = ...
    validateServerSsl = ...
    validateClientSsl = ...
    logger = ...
    verbose = ...
    markets = ...
    symbols = ...
    codes = ...
    timeframes = ...
    tokenBucket = ...
    fees = ...
    loaded_fees = ...
    ids = ...
    urls = ...
    api = ...
    parseJsonResponse = ...
    throttler = ...
    proxy = ...
    proxyUrl = ...
    proxy_url = ...
    proxyUrlCallback = ...
    proxy_url_callback = ...
    httpProxy = ...
    http_proxy = ...
    httpProxyCallback = ...
    http_proxy_callback = ...
    httpsProxy = ...
    https_proxy = ...
    httpsProxyCallback = ...
    https_proxy_callback = ...
    socksProxy = ...
    socks_proxy = ...
    socksProxyCallback = ...
    socks_proxy_callback = ...
    userAgent = ...
    user_agent = ...
    wsProxy = ...
    ws_proxy = ...
    wssProxy = ...
    wss_proxy = ...
    wsSocksProxy = ...
    ws_socks_proxy = ...
    userAgents = ...
    headers = ...
    returnResponseHeaders = ...
    origin = ...
    MAX_VALUE = ...
    proxies = ...
    hostname = ...
    apiKey = ...
    secret = ...
    password = ...
    uid = ...
    accountId = ...
    privateKey = ...
    walletAddress = ...
    token = ...
    twofa = ...
    markets_by_id = ...
    currencies_by_id = ...
    precision = ...
    exceptions = ...
    limits = ...
    httpExceptions = ...
    balance = ...
    liquidations = ...
    orderbooks = ...
    orders = ...
    triggerOrders = ...
    myLiquidations = ...
    myTrades = ...
    trades = ...
    transactions = ...
    ohlcvs = ...
    tickers = ...
    fundingRates = ...
    bidsasks = ...
    base_currencies = ...
    quote_currencies = ...
    currencies = ...
    options = ...
    isSandboxModeEnabled = ...
    accounts = ...
    positions = ...
    status = ...
    requiredCredentials = ...
    has = ...
    features = ...
    precisionMode = ...
    paddingMode = ...
    minFundingAddressLength = ...
    substituteCommonCurrencyCodes = ...
    quoteJsonNumbers = ...
    number: Num = ...
    handleContentTypeApplicationZip = ...
    reduceFees = ...
    lastRestRequestTimestamp = ...
    lastRestPollTimestamp = ...
    restRequestQueue = ...
    restPollerLoopIsRunning = ...
    rateLimitTokens = ...
    rateLimitMaxTokens = ...
    rateLimitUpdateTime = ...
    enableLastHttpResponse = ...
    enableLastJsonResponse = ...
    enableLastResponseHeaders = ...
    last_http_response = ...
    last_json_response = ...
    last_response_headers = ...
    last_request_body = ...
    last_request_url = ...
    last_request_headers = ...
    requiresEddsa = ...
    base58_encoder = ...
    base58_decoder = ...
    base58_alphabet = ...
    commonCurrencies = ...
    synchronous = ...
    def __init__(self, config: ConstructorArgs = ...) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    def init_throttler(self, cost=...): # -> None:
        ...
    
    def throttle(self, cost=...): # -> None:
        ...
    
    @staticmethod
    def gzip_deflate(response, text): # -> bytes:
        ...
    
    def prepare_request_headers(self, headers=...): # -> dict[Any, Any]:
        ...
    
    def log(self, *args): # -> None:
        ...
    
    def on_rest_response(self, code, reason, url, method, response_headers, response_body, request_headers, request_body):
        ...
    
    def on_json_response(self, response_body): # -> Any:
        ...
    
    def fetch(self, url, method=..., headers=..., body=...):
        """Perform a HTTP request and return decoded JSON data"""
        ...
    
    def parse_json(self, http_response): # -> Any | None:
        ...
    
    def is_text_response(self, headers):
        ...
    
    @staticmethod
    def key_exists(dictionary, key): # -> Literal[False]:
        ...
    
    @staticmethod
    def safe_float(dictionary, key, default_value=...): # -> float | None:
        ...
    
    @staticmethod
    def safe_string(dictionary, key, default_value=...): # -> str | None:
        ...
    
    @staticmethod
    def safe_string_lower(dictionary, key, default_value=...): # -> str | None:
        ...
    
    @staticmethod
    def safe_string_upper(dictionary, key, default_value=...): # -> str | None:
        ...
    
    @staticmethod
    def safe_integer(dictionary, key, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_integer_product(dictionary, key, factor, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_timestamp(dictionary, key, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_value(dictionary, key, default_value=...): # -> None:
        ...
    
    @staticmethod
    def safe_float_2(dictionary, key1, key2, default_value=...):
        ...
    
    @staticmethod
    def safe_string_2(dictionary, key1, key2, default_value=...):
        ...
    
    @staticmethod
    def safe_string_lower_2(dictionary, key1, key2, default_value=...):
        ...
    
    @staticmethod
    def safe_string_upper_2(dictionary, key1, key2, default_value=...):
        ...
    
    @staticmethod
    def safe_integer_2(dictionary, key1, key2, default_value=...):
        ...
    
    @staticmethod
    def safe_integer_product_2(dictionary, key1, key2, factor, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_timestamp_2(dictionary, key1, key2, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_value_2(dictionary, key1, key2, default_value=...):
        ...
    
    @staticmethod
    def safe_float_n(dictionary, key_list, default_value=...): # -> float | None:
        ...
    
    @staticmethod
    def safe_string_n(dictionary, key_list, default_value=...): # -> str | None:
        ...
    
    @staticmethod
    def safe_string_lower_n(dictionary, key_list, default_value=...): # -> str | None:
        ...
    
    @staticmethod
    def safe_string_upper_n(dictionary, key_list, default_value=...): # -> str | None:
        ...
    
    @staticmethod
    def safe_integer_n(dictionary, key_list, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_integer_product_n(dictionary, key_list, factor, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_timestamp_n(dictionary, key_list, default_value=...): # -> int | None:
        ...
    
    @staticmethod
    def safe_value_n(dictionary, key_list, default_value=...): # -> None:
        ...
    
    @staticmethod
    def get_object_value_from_key_list(dictionary_or_list, key_list): # -> None:
        ...
    
    @staticmethod
    def safe_either(method, dictionary, key1, key2, default_value=...):
        """A helper-wrapper for the safe_value_2() family."""
        ...
    
    @staticmethod
    def truncate(num, precision=...): # -> int:
        """Deprecated, use decimal_to_precision instead"""
        ...
    
    @staticmethod
    def truncate_to_string(num, precision=...): # -> str:
        """Deprecated, todo: remove references from subclasses"""
        ...
    
    @staticmethod
    def uuid22(length=...): # -> str:
        ...
    
    @staticmethod
    def uuid16(length=...): # -> str:
        ...
    
    @staticmethod
    def uuid(): # -> str:
        ...
    
    @staticmethod
    def uuidv1(): # -> str:
        ...
    
    @staticmethod
    def capitalize(string): # -> LiteralString:
        ...
    
    @staticmethod
    def strip(string):
        ...
    
    @staticmethod
    def keysort(dictionary): # -> OrderedDict[Any, Any]:
        ...
    
    @staticmethod
    def sort(array): # -> list[Any]:
        ...
    
    @staticmethod
    def extend(*args): # -> OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    @staticmethod
    def deep_extend(*args): # -> dict[Any, Any] | None:
        ...
    
    @staticmethod
    def filter_by(array, key, value=...): # -> list[Any]:
        ...
    
    @staticmethod
    def filterBy(array, key, value=...): # -> list[Any]:
        ...
    
    @staticmethod
    def group_by(array, key): # -> dict[Any, Any]:
        ...
    
    @staticmethod
    def groupBy(array, key): # -> dict[Any, Any]:
        ...
    
    @staticmethod
    def index_by_safe(array, key): # -> dict[Any, Any]:
        ...
    
    @staticmethod
    def index_by(array, key): # -> dict[Any, Any]:
        ...
    
    @staticmethod
    def sort_by(array, key, descending=..., default=...): # -> list[Any]:
        ...
    
    @staticmethod
    def sort_by_2(array, key1, key2, descending=...): # -> list[Any]:
        ...
    
    @staticmethod
    def array_concat(a, b):
        ...
    
    @staticmethod
    def in_array(needle, haystack): # -> bool:
        ...
    
    @staticmethod
    def is_empty(object): # -> bool:
        ...
    
    @staticmethod
    def extract_params(string): # -> list[Any]:
        ...
    
    @staticmethod
    def implode_params(string, params):
        ...
    
    @staticmethod
    def urlencode(params=..., doseq=..., sort=...): # -> str:
        ...
    
    @staticmethod
    def urlencode_with_array_repeat(params=...): # -> str:
        ...
    
    @staticmethod
    def urlencode_nested(params): # -> str:
        ...
    
    @staticmethod
    def rawencode(params=..., sort=...): # -> str:
        ...
    
    @staticmethod
    def encode_uri_component(uri, safe=...): # -> str:
        ...
    
    @staticmethod
    def omit(d, *args): # -> dict[Any, Any]:
        ...
    
    @staticmethod
    def unique(array): # -> list[Any]:
        ...
    
    @staticmethod
    def pluck(array, key): # -> list[Any]:
        ...
    
    @staticmethod
    def sum(*args): # -> float | int:
        ...
    
    @staticmethod
    def ordered(array): # -> OrderedDict[Any, Any]:
        ...
    
    @staticmethod
    def aggregate(bidasks): # -> list[Any]:
        ...
    
    @staticmethod
    def sec(): # -> int:
        ...
    
    @staticmethod
    def msec(): # -> int:
        ...
    
    @staticmethod
    def usec(): # -> int:
        ...
    
    @staticmethod
    def seconds(): # -> int:
        ...
    
    @staticmethod
    def milliseconds(): # -> int:
        ...
    
    @staticmethod
    def microseconds(): # -> int:
        ...
    
    @staticmethod
    def iso8601(timestamp=...): # -> str | None:
        ...
    
    @staticmethod
    def rfc2616(self, timestamp=...): # -> str:
        ...
    
    @staticmethod
    def dmy(timestamp, infix=...): # -> str:
        ...
    
    @staticmethod
    def ymd(timestamp, infix=..., fullYear=...): # -> str:
        ...
    
    @staticmethod
    def yymmdd(timestamp, infix=...): # -> str:
        ...
    
    @staticmethod
    def yyyymmdd(timestamp, infix=...): # -> str:
        ...
    
    @staticmethod
    def ymdhms(timestamp, infix=...): # -> str:
        ...
    
    @staticmethod
    def parse_date(timestamp=...): # -> int | None:
        ...
    
    @staticmethod
    def parse8601(timestamp=...): # -> int | None:
        ...
    
    @staticmethod
    def hash(request, algorithm=..., digest=...): # -> bytes:
        ...
    
    @staticmethod
    def hmac(request, secret, algorithm=..., digest=...): # -> bytes:
        ...
    
    @staticmethod
    def binary_concat(*args): # -> bytes:
        ...
    
    @staticmethod
    def binary_concat_array(array): # -> bytes:
        ...
    
    @staticmethod
    def urlencode_base64(s):
        ...
    
    @staticmethod
    def binary_to_base64(s):
        ...
    
    @staticmethod
    def base64_to_binary(s): # -> bytes:
        ...
    
    @staticmethod
    def string_to_base64(s):
        ...
    
    @staticmethod
    def base64_to_string(s):
        ...
    
    @staticmethod
    def jwt(request, secret, algorithm=..., is_rsa=..., opts=...):
        ...
    
    @staticmethod
    def rsa(request, secret, alg=...):
        ...
    
    @staticmethod
    def eth_abi_encode(types, args): # -> bytes:
        ...
    
    @staticmethod
    def eth_encode_structured_data(domain, messageTypes, message): # -> bytes:
        ...
    
    @staticmethod
    def retrieve_stark_account(signature, accountClassHash, accountProxyClassHash): # -> dict[str, Any]:
        ...
    
    @staticmethod
    def starknet_encode_structured_data(domain, messageTypes, messageData, address): # -> int:
        ...
    
    @staticmethod
    def starknet_sign(msg_hash, pri): # -> str:
        ...
    
    @staticmethod
    def packb(o): # -> None:
        ...
    
    @staticmethod
    def int_to_base16(num):
        ...
    
    @staticmethod
    def random_bytes(length): # -> str:
        ...
    
    @staticmethod
    def ecdsa(request, secret, algorithm=..., hash=..., fixed_length=...): # -> dict[str, Any]:
        ...
    
    @staticmethod
    def binary_to_urlencoded_base64(data: bytes) -> str:
        ...
    
    @staticmethod
    def eddsa(request, secret, curve=..., url_encode=...): # -> str:
        ...
    
    @staticmethod
    def axolotl(request, secret, curve=...): # -> LiteralString:
        ...
    
    @staticmethod
    def json(data, params=...): # -> str:
        ...
    
    @staticmethod
    def is_json_encoded_object(input): # -> bool:
        ...
    
    @staticmethod
    def encode(string):
        ...
    
    @staticmethod
    def decode(string):
        ...
    
    @staticmethod
    def to_array(value): # -> list[Any]:
        ...
    
    @staticmethod
    def check_required_version(required_version, error=...): # -> bool:
        ...
    
    def precision_from_string(self, str): # -> int:
        ...
    
    def map_to_safe_map(self, dictionary):
        ...
    
    def safe_map_to_map(self, dictionary):
        ...
    
    def load_markets(self, reload=..., params=...): # -> dict[Any, Any]:
        """
        Loads and prepares the markets for trading.

        Args:
            reload (bool): If True, the markets will be reloaded from the exchange.
            params (dict): Additional exchange-specific parameters for the request.

        Returns:
            dict: A dictionary of markets.

        Raises:
            Exception: If the markets cannot be loaded or prepared.

        Notes:
            It ensures that the markets are only loaded once, even if called multiple times.
            If the markets are already loaded and `reload` is False or not provided, it returns the existing markets.
            If a reload is in progress, it waits for completion before returning.
            If an error occurs during loading or preparation, an exception is raised.
        """
        ...
    
    def fetch_markets(self, params=...): # -> list[Any]:
        ...
    
    def fetch_currencies(self, params=...): # -> dict[Any, Any] | None:
        ...
    
    def fetch_fees(self): # -> dict[str, Any]:
        ...
    
    @staticmethod
    def parse_timeframe(timeframe): # -> int:
        ...
    
    @staticmethod
    def round_timeframe(timeframe, timestamp, direction=...):
        ...
    
    def vwap(self, baseVolume, quoteVolume): # -> None:
        ...
    
    def check_required_dependencies(self): # -> None:
        ...
    
    def privateKeyToAddress(self, privateKey):
        ...
    
    @staticmethod
    def remove0x_prefix(value):
        ...
    
    @staticmethod
    def totp(key): # -> str:
        ...
    
    @staticmethod
    def number_to_le(n, size): # -> bytes:
        ...
    
    @staticmethod
    def number_to_be(n, size): # -> bytes:
        ...
    
    @staticmethod
    def base16_to_binary(s): # -> bytes:
        ...
    
    @staticmethod
    def binary_to_base16(s):
        ...
    
    def sleep(self, milliseconds): # -> None:
        ...
    
    @staticmethod
    def base58_to_binary(s): # -> bytes:
        """encodes a base58 string to as a big endian integer"""
        ...
    
    @staticmethod
    def binary_to_base58(b): # -> LiteralString:
        ...
    
    def parse_number(self, value, default=...): # -> None:
        ...
    
    def omit_zero(self, string_number): # -> Literal[''] | None:
        ...
    
    def check_order_arguments(self, market, type, side, amount, price, params): # -> None:
        ...
    
    def handle_http_status_code(self, code, reason, url, method, body): # -> None:
        ...
    
    @staticmethod
    def crc32(string, signed=...): # -> int:
        ...
    
    def clone(self, obj): # -> list[Any] | OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def convert_to_big_int(self, value): # -> int:
        ...
    
    def string_to_chars_array(self, value): # -> list[Any]:
        ...
    
    def value_is_defined(self, value): # -> bool:
        ...
    
    def array_slice(self, array, first, second=...):
        ...
    
    def get_property(self, obj, property, defaultValue=...): # -> Any | None:
        ...
    
    def set_property(self, obj, property, value): # -> None:
        ...
    
    def un_camel_case(self, str): # -> str:
        ...
    
    def fix_stringified_json_members(self, content):
        ...
    
    def extend_exchange_options(self, newOptions): # -> None:
        ...
    
    def create_safe_dictionary(self): # -> dict[Any, Any]:
        ...
    
    def convert_to_safe_dictionary(self, dictionary):
        ...
    
    def rand_number(self, size): # -> int:
        ...
    
    def binary_length(self, binary): # -> int:
        ...
    
    def get_zk_contract_signature_obj(self, seeds: str, params=...):
        ...
    
    def get_zk_transfer_signature_obj(self, seeds: str, params=...):
        ...
    
    def is_binary_message(self, message): # -> bool:
        ...
    
    def describe(self) -> Any:
        ...
    
    def safe_bool_n(self, dictionaryOrList, keys: List[IndexType], defaultValue: bool = ...): # -> bool:
        """
 @ignore
        safely extract boolean value from dictionary or list
        :returns bool | None:
        """
        ...
    
    def safe_bool_2(self, dictionary, key1: IndexType, key2: IndexType, defaultValue: bool = ...): # -> bool:
        """
 @ignore
        safely extract boolean value from dictionary or list
        :returns bool | None:
        """
        ...
    
    def safe_bool(self, dictionary, key: IndexType, defaultValue: bool = ...): # -> bool:
        """
 @ignore
        safely extract boolean value from dictionary or list
        :returns bool | None:
        """
        ...
    
    def safe_dict_n(self, dictionaryOrList, keys: List[IndexType], defaultValue: dict = ...): # -> dict[Any, Any]:
        """
 @ignore
        safely extract a dictionary from dictionary or list
        :returns dict | None:
        """
        ...
    
    def safe_dict(self, dictionary, key: IndexType, defaultValue: dict = ...): # -> dict[Any, Any]:
        """
 @ignore
        safely extract a dictionary from dictionary or list
        :returns dict | None:
        """
        ...
    
    def safe_dict_2(self, dictionary, key1: IndexType, key2: str, defaultValue: dict = ...): # -> dict[Any, Any]:
        """
 @ignore
        safely extract a dictionary from dictionary or list
        :returns dict | None:
        """
        ...
    
    def safe_list_n(self, dictionaryOrList, keys: List[IndexType], defaultValue: List[Any] = ...): # -> List[Any] | list[Any]:
        """
 @ignore
        safely extract an Array from dictionary or list
        :returns Array | None:
        """
        ...
    
    def safe_list_2(self, dictionaryOrList, key1: IndexType, key2: str, defaultValue: List[Any] = ...): # -> List[Any] | list[Any]:
        """
 @ignore
        safely extract an Array from dictionary or list
        :returns Array | None:
        """
        ...
    
    def safe_list(self, dictionaryOrList, key: IndexType, defaultValue: List[Any] = ...): # -> List[Any] | list[Any]:
        """
 @ignore
        safely extract an Array from dictionary or list
        :returns Array | None:
        """
        ...
    
    def handle_deltas(self, orderbook, deltas): # -> None:
        ...
    
    def handle_delta(self, bookside, delta):
        ...
    
    def handle_deltas_with_keys(self, bookSide: Any, deltas, priceKey: IndexType = ..., amountKey: IndexType = ..., countOrIdKey: IndexType = ...): # -> None:
        ...
    
    def get_cache_index(self, orderbook, deltas): # -> Literal[-1]:
        ...
    
    def arrays_concat(self, arraysOfArrays: List[Any]): # -> list[Any]:
        ...
    
    def find_timeframe(self, timeframe, timeframes=...): # -> None:
        ...
    
    def check_proxy_url_settings(self, url: Str = ..., method: Str = ..., headers=..., body=...): # -> None:
        ...
    
    def url_encoder_for_proxy_url(self, targetUrl: str): # -> str:
        ...
    
    def check_proxy_settings(self, url: Str = ..., method: Str = ..., headers=..., body=...): # -> list[Any | None]:
        ...
    
    def check_ws_proxy_settings(self): # -> list[None]:
        ...
    
    def check_conflicting_proxies(self, proxyAgentSet, proxyUrlSet): # -> None:
        ...
    
    def check_address(self, address: Str = ...): # -> str:
        ...
    
    def find_message_hashes(self, client, element: str): # -> list[Any]:
        ...
    
    def filter_by_limit(self, array: List[object], limit: Int = ..., key: IndexType = ..., fromStart: bool = ...): # -> List[object]:
        ...
    
    def filter_by_since_limit(self, array: List[object], since: Int = ..., limit: Int = ..., key: IndexType = ..., tail=...): # -> list[Any] | List[object]:
        ...
    
    def filter_by_value_since_limit(self, array: List[object], field: IndexType, value=..., since: Int = ..., limit: Int = ..., key=..., tail=...): # -> list[Any] | List[object]:
        ...
    
    def set_sandbox_mode(self, enabled: bool): # -> None:
        """
        set the sandbox mode for the exchange
        :param boolean enabled: True to enable sandbox mode, False to disable it
        """
        ...
    
    def enable_demo_trading(self, enable: bool): # -> None:
        """
        enables or disables demo trading mode
        :param boolean [enable]: True if demo trading should be enabled, False otherwise
        """
        ...
    
    def sign(self, path, api: Any = ..., method=..., params=..., headers: Any = ..., body: Any = ...): # -> dict[Any, Any]:
        ...
    
    def fetch_accounts(self, params=...):
        ...
    
    def fetch_trades(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_trades_ws(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_liquidations(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_liquidations_for_symbols(self, symbols: List[str], since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_my_liquidations(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_my_liquidations_for_symbols(self, symbols: List[str], since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_trades(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def un_watch_orders(self, symbol: Str = ..., params=...):
        ...
    
    def un_watch_trades(self, symbol: str, params=...):
        ...
    
    def watch_trades_for_symbols(self, symbols: List[str], since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def un_watch_trades_for_symbols(self, symbols: List[str], params=...):
        ...
    
    def watch_my_trades_for_symbols(self, symbols: List[str], since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_orders_for_symbols(self, symbols: List[str], since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_ohlcv_for_symbols(self, symbolsAndTimeframes: List[List[str]], since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def un_watch_ohlcv_for_symbols(self, symbolsAndTimeframes: List[List[str]], params=...):
        ...
    
    def watch_order_book_for_symbols(self, symbols: List[str], limit: Int = ..., params=...):
        ...
    
    def un_watch_order_book_for_symbols(self, symbols: List[str], params=...):
        ...
    
    def un_watch_positions(self, symbols: Strings = ..., params=...):
        ...
    
    def un_watch_ticker(self, symbol: str, params=...):
        ...
    
    def un_watch_mark_price(self, symbol: str, params=...):
        ...
    
    def un_watch_mark_prices(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_deposit_addresses(self, codes: Strings = ..., params=...):
        ...
    
    def fetch_order_book(self, symbol: str, limit: Int = ..., params=...):
        ...
    
    def fetch_order_book_ws(self, symbol: str, limit: Int = ..., params=...):
        ...
    
    def fetch_margin_mode(self, symbol: str, params=...):
        ...
    
    def fetch_margin_modes(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_rest_order_book_safe(self, symbol, limit=..., params=...): # -> None:
        ...
    
    def watch_order_book(self, symbol: str, limit: Int = ..., params=...):
        ...
    
    def un_watch_order_book(self, symbol: str, params=...):
        ...
    
    def fetch_time(self, params=...):
        ...
    
    def fetch_trading_limits(self, symbols: Strings = ..., params=...):
        ...
    
    def parse_currency(self, rawCurrency: dict):
        ...
    
    def parse_currencies(self, rawCurrencies): # -> dict[Any, Any]:
        ...
    
    def parse_market(self, market: dict):
        ...
    
    def parse_markets(self, markets): # -> list[Any]:
        ...
    
    def parse_ticker(self, ticker: dict, market: Market = ...):
        ...
    
    def parse_deposit_address(self, depositAddress, currency: Currency = ...):
        ...
    
    def parse_trade(self, trade: dict, market: Market = ...):
        ...
    
    def parse_transaction(self, transaction: dict, currency: Currency = ...):
        ...
    
    def parse_transfer(self, transfer: dict, currency: Currency = ...):
        ...
    
    def parse_account(self, account: dict):
        ...
    
    def parse_ledger_entry(self, item: dict, currency: Currency = ...):
        ...
    
    def parse_order(self, order: dict, market: Market = ...):
        ...
    
    def fetch_cross_borrow_rates(self, params=...):
        ...
    
    def fetch_isolated_borrow_rates(self, params=...):
        ...
    
    def parse_market_leverage_tiers(self, info, market: Market = ...):
        ...
    
    def fetch_leverage_tiers(self, symbols: Strings = ..., params=...):
        ...
    
    def parse_position(self, position: dict, market: Market = ...):
        ...
    
    def parse_funding_rate_history(self, info, market: Market = ...):
        ...
    
    def parse_borrow_interest(self, info: dict, market: Market = ...):
        ...
    
    def parse_isolated_borrow_rate(self, info: dict, market: Market = ...):
        ...
    
    def parse_ws_trade(self, trade: dict, market: Market = ...):
        ...
    
    def parse_ws_order(self, order: dict, market: Market = ...):
        ...
    
    def parse_ws_order_trade(self, trade: dict, market: Market = ...):
        ...
    
    def parse_ws_ohlcv(self, ohlcv, market: Market = ...): # -> list[Any]:
        ...
    
    def fetch_funding_rates(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_funding_intervals(self, symbols: Strings = ..., params=...):
        ...
    
    def watch_funding_rate(self, symbol: str, params=...):
        ...
    
    def watch_funding_rates(self, symbols: List[str], params=...):
        ...
    
    def watch_funding_rates_for_symbols(self, symbols: List[str], params=...):
        ...
    
    def transfer(self, code: str, amount: float, fromAccount: str, toAccount: str, params=...):
        ...
    
    def withdraw(self, code: str, amount: float, address: str, tag: Str = ..., params=...):
        ...
    
    def create_deposit_address(self, code: str, params=...):
        ...
    
    def set_leverage(self, leverage: int, symbol: Str = ..., params=...):
        ...
    
    def fetch_leverage(self, symbol: str, params=...):
        ...
    
    def fetch_leverages(self, symbols: Strings = ..., params=...):
        ...
    
    def set_position_mode(self, hedged: bool, symbol: Str = ..., params=...):
        ...
    
    def add_margin(self, symbol: str, amount: float, params=...):
        ...
    
    def reduce_margin(self, symbol: str, amount: float, params=...):
        ...
    
    def set_margin(self, symbol: str, amount: float, params=...):
        ...
    
    def fetch_long_short_ratio(self, symbol: str, timeframe: Str = ..., params=...):
        ...
    
    def fetch_long_short_ratio_history(self, symbol: Str = ..., timeframe: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_margin_adjustment_history(self, symbol: Str = ..., type: Str = ..., since: Num = ..., limit: Num = ..., params=...):
        """
        fetches the history of margin added or reduced from contract isolated positions
        :param str [symbol]: unified market symbol
        :param str [type]: "add" or "reduce"
        :param int [since]: timestamp in ms of the earliest change to fetch
        :param int [limit]: the maximum amount of changes to fetch
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns dict[]: a list of `margin structures <https://docs.ccxt.com/#/?id=margin-loan-structure>`
        """
        ...
    
    def set_margin_mode(self, marginMode: str, symbol: Str = ..., params=...):
        ...
    
    def fetch_deposit_addresses_by_network(self, code: str, params=...):
        ...
    
    def fetch_open_interest_history(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_open_interest(self, symbol: str, params=...):
        ...
    
    def fetch_open_interests(self, symbols: Strings = ..., params=...):
        ...
    
    def sign_in(self, params=...):
        ...
    
    def fetch_payment_methods(self, params=...):
        ...
    
    def parse_to_int(self, number): # -> int:
        ...
    
    def parse_to_numeric(self, number): # -> float | int:
        ...
    
    def is_round_number(self, value: float): # -> bool:
        ...
    
    def safe_number_omit_zero(self, obj: object, key: IndexType, defaultValue: Num = ...): # -> Num:
        ...
    
    def safe_integer_omit_zero(self, obj: object, key: IndexType, defaultValue: Int = ...): # -> int | None:
        ...
    
    def after_construct(self): # -> None:
        ...
    
    def init_rest_rate_limiter(self): # -> None:
        ...
    
    def features_generator(self): # -> None:
        ...
    
    def features_mapper(self, initialFeatures: Any, marketType: Str, subType: Str = ...): # -> dict[Any, Any] | Any | None:
        ...
    
    def feature_value(self, symbol: str, methodName: Str = ..., paramName: Str = ..., defaultValue: Any = ...): # -> Any:
        """
        self method is a very deterministic to help users to know what feature is supported by the exchange
        :param str [symbol]: unified symbol
        :param str [methodName]: view currently supported methods: https://docs.ccxt.com/#/README?id=features
        :param str [paramName]: unified param value, like: `triggerPrice`, `stopLoss.triggerPrice`(check docs for supported param names)
        :param dict [defaultValue]: return default value if no result found
        :returns dict: returns feature value
        """
        ...
    
    def feature_value_by_type(self, marketType: str, subType: Str, methodName: Str = ..., paramName: Str = ..., defaultValue: Any = ...): # -> Any:
        """
        self method is a very deterministic to help users to know what feature is supported by the exchange
        :param str [marketType]: supported only: "spot", "swap", "future"
        :param str [subType]: supported only: "linear", "inverse"
        :param str [methodName]: view currently supported methods: https://docs.ccxt.com/#/README?id=features
        :param str [paramName]: unified param value(check docs for supported param names)
        :param dict [defaultValue]: return default value if no result found
        :returns dict: returns feature value
        """
        ...
    
    def orderbook_checksum_message(self, symbol: Str): # -> str:
        ...
    
    def create_networks_by_id_object(self): # -> None:
        ...
    
    def get_default_options(self): # -> dict[str, dict[str, dict[str, str]]]:
        ...
    
    def safe_ledger_entry(self, entry: object, currency: Currency = ...): # -> dict[str, Any]:
        ...
    
    def safe_currency_structure(self, currency: object): # -> OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def safe_market_structure(self, market: dict = ...): # -> OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def set_markets(self, markets, currencies=...): # -> dict[Any, Any]:
        ...
    
    def set_markets_from_exchange(self, sourceExchange): # -> Self:
        ...
    
    def get_describe_for_extended_ws_exchange(self, currentRestInstance: Any, parentRestInstance: Any, wsBaseDescribe: dict): # -> dict[Any, Any] | None:
        ...
    
    def safe_balance(self, balance: dict): # -> dict[Any, Any]:
        ...
    
    def safe_order(self, order: dict, market: Market = ...): # -> OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def parse_orders(self, orders: object, market: Market = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def calculate_fee_with_rate(self, symbol: str, type: str, side: str, amount: float, price: float, takerOrMaker=..., feeRate: Num = ..., params=...): # -> dict[str, Any]:
        ...
    
    def calculate_fee(self, symbol: str, type: str, side: str, amount: float, price: float, takerOrMaker=..., params=...): # -> dict[str, Any]:
        """
        calculates the presumptive fee that would be charged for an order
        :param str symbol: unified market symbol
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade, in units of the base currency on most exchanges, or number of contracts
        :param float price: the price for the order to be filled at, in units of the quote currency
        :param str takerOrMaker: 'taker' or 'maker'
        :param dict params:
        :returns dict: contains the rate, the percentage multiplied to the order amount to obtain the fee amount, and cost, the total value of the fee in units of the quote currency, for the order
        """
        ...
    
    def safe_liquidation(self, liquidation: dict, market: Market = ...): # -> dict[Any, Any]:
        ...
    
    def safe_trade(self, trade: dict, market: Market = ...): # -> dict[Any, Any]:
        ...
    
    def create_ccxt_trade_id(self, timestamp=..., side=..., amount=..., price=..., takerOrMaker=...): # -> str | None:
        ...
    
    def parsed_fee_and_fees(self, container: Any): # -> list[Any]:
        ...
    
    def parse_fee_numeric(self, fee: Any): # -> Any:
        ...
    
    def find_nearest_ceiling(self, arr: List[float], providedValue: float): # -> float:
        ...
    
    def invert_flat_string_dictionary(self, dict): # -> dict[Any, Any]:
        ...
    
    def reduce_fees_by_currency(self, fees): # -> list[Any]:
        ...
    
    def safe_ticker(self, ticker: dict, market: Market = ...): # -> OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def fetch_borrow_rate(self, code: str, amount: float, params=...):
        ...
    
    def repay_cross_margin(self, code: str, amount: float, params=...):
        ...
    
    def repay_isolated_margin(self, symbol: str, code: str, amount: float, params=...):
        ...
    
    def borrow_cross_margin(self, code: str, amount: float, params=...):
        ...
    
    def borrow_isolated_margin(self, symbol: str, code: str, amount: float, params=...):
        ...
    
    def borrow_margin(self, code: str, amount: float, symbol: Str = ..., params=...):
        ...
    
    def repay_margin(self, code: str, amount: float, symbol: Str = ..., params=...):
        ...
    
    def fetch_ohlcv(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_ohlcv_ws(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_ohlcv(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def convert_trading_view_to_ohlcv(self, ohlcvs: List[List[float]], timestamp=..., open=..., high=..., low=..., close=..., volume=..., ms=...): # -> list[Any]:
        ...
    
    def convert_ohlcv_to_trading_view(self, ohlcvs: List[List[float]], timestamp=..., open=..., high=..., low=..., close=..., volume=..., ms=...): # -> dict[Any, Any]:
        ...
    
    def fetch_web_endpoint(self, method, endpointMethod, returnAsJson, startRegex=..., endRegex=...): # -> Any | None:
        ...
    
    def market_ids(self, symbols: Strings = ...): # -> list[Any] | None:
        ...
    
    def currency_ids(self, codes: Strings = ...): # -> list[Any] | None:
        ...
    
    def markets_for_symbols(self, symbols: Strings = ...): # -> list[Any] | None:
        ...
    
    def market_symbols(self, symbols: Strings = ..., type: Str = ..., allowEmpty=..., sameTypeOnly=..., sameSubTypeOnly=...): # -> List[str] | list[Any] | None:
        ...
    
    def market_codes(self, codes: Strings = ...): # -> list[Any] | None:
        ...
    
    def parse_bids_asks(self, bidasks, priceKey: IndexType = ..., amountKey: IndexType = ..., countOrIdKey: IndexType = ...): # -> list[Any]:
        ...
    
    def fetch_l2_order_book(self, symbol: str, limit: Int = ..., params=...):
        ...
    
    def filter_by_symbol(self, objects, symbol: Str = ...): # -> list[Any]:
        ...
    
    def parse_ohlcv(self, ohlcv, market: Market = ...) -> list:
        ...
    
    def network_code_to_id(self, networkCode: str, currencyCode: Str = ...): # -> str:
        """
 @ignore
        tries to convert the provided networkCode(which is expected to be an unified network code) to a network id. In order to achieve self, derived class needs to have 'options->networks' defined.
        :param str networkCode: unified network code
        :param str currencyCode: unified currency code, but self argument is not required by default, unless there is an exchange(like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
        :returns str|None: exchange-specific network id
        """
        ...
    
    def network_id_to_code(self, networkId: Str = ..., currencyCode: Str = ...): # -> str | None:
        """
 @ignore
        tries to convert the provided exchange-specific networkId to an unified network Code. In order to achieve self, derived class needs to have "options['networksById']" defined.
        :param str networkId: exchange specific network id/title, like: TRON, Trc-20, usdt-erc20, etc
        :param str|None currencyCode: unified currency code, but self argument is not required by default, unless there is an exchange(like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
        :returns str|None: unified network code
        """
        ...
    
    def handle_network_code_and_params(self, params): # -> list[Any]:
        ...
    
    def default_network_code(self, currencyCode: str): # -> str | None:
        ...
    
    def select_network_code_from_unified_networks(self, currencyCode, networkCode, indexedNetworkEntries): # -> str | None:
        ...
    
    def select_network_id_from_raw_networks(self, currencyCode, networkCode, indexedNetworkEntries): # -> str | None:
        ...
    
    def select_network_key_from_networks(self, currencyCode, networkCode, indexedNetworkEntries, isIndexedByUnifiedNetworkCode=...): # -> str | None:
        ...
    
    def safe_number_2(self, dictionary: object, key1: IndexType, key2: IndexType, d=...): # -> None:
        ...
    
    def parse_order_book(self, orderbook: object, symbol: str, timestamp: Int = ..., bidsKey=..., asksKey=..., priceKey: IndexType = ..., amountKey: IndexType = ..., countOrIdKey: IndexType = ...): # -> dict[str, Any]:
        ...
    
    def parse_ohlcvs(self, ohlcvs: List[object], market: Any = ..., timeframe: str = ..., since: Int = ..., limit: Int = ..., tail: Bool = ...): # -> list[Any] | List[object]:
        ...
    
    def parse_leverage_tiers(self, response: Any, symbols: List[str] = ..., marketIdKey=...): # -> dict[Any, Any]:
        ...
    
    def load_trading_limits(self, symbols: Strings = ..., reload=..., params=...): # -> dict[Any, Any] | None:
        ...
    
    def safe_position(self, position: dict): # -> dict[Any, Any]:
        ...
    
    def parse_positions(self, positions: List[Any], symbols: List[str] = ..., params=...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_accounts(self, accounts: List[Any], params=...): # -> list[Any]:
        ...
    
    def parse_trades_helper(self, isWs: bool, trades: List[Any], market: Market = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def parse_trades(self, trades: List[Any], market: Market = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def parse_ws_trades(self, trades: List[Any], market: Market = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def parse_transactions(self, transactions: List[Any], currency: Currency = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def parse_transfers(self, transfers: List[Any], currency: Currency = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def parse_ledger(self, data, currency: Currency = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def nonce(self): # -> int:
        ...
    
    def set_headers(self, headers):
        ...
    
    def currency_id(self, code: str): # -> str:
        ...
    
    def market_id(self, symbol: str): # -> str:
        ...
    
    def symbol(self, symbol: str): # -> str | None:
        ...
    
    def handle_param_string(self, params: object, paramName: str, defaultValue: Str = ...): # -> list[Any]:
        ...
    
    def handle_param_string_2(self, params: object, paramName1: str, paramName2: str, defaultValue: Str = ...): # -> list[Any]:
        ...
    
    def handle_param_integer(self, params: object, paramName: str, defaultValue: Int = ...): # -> list[Any]:
        ...
    
    def handle_param_integer_2(self, params: object, paramName1: str, paramName2: str, defaultValue: Int = ...): # -> list[Any]:
        ...
    
    def handle_param_bool(self, params: object, paramName: str, defaultValue: Bool = ...): # -> list[Any]:
        ...
    
    def handle_param_bool_2(self, params: object, paramName1: str, paramName2: str, defaultValue: Bool = ...): # -> list[Any]:
        ...
    
    def handle_request_network(self, params: dict, request: dict, exchangeSpecificKey: str, currencyCode: Str = ..., isRequired: bool = ...): # -> list[Any]:
        """
        :param dict params: - extra parameters
        :param dict request: - existing dictionary of request
        :param str exchangeSpecificKey: - the key for chain id to be set in request
        :param dict currencyCode: - (optional) existing dictionary of request
        :param boolean isRequired: - (optional) whether that param is required to be present
        :returns dict[]: - returns [request, params] where request is the modified request object and params is the modified params object
        """
        ...
    
    def resolve_path(self, path, params): # -> list[Any]:
        ...
    
    def get_list_from_object_values(self, objects, key: IndexType): # -> list[Any]:
        ...
    
    def get_symbols_for_market_type(self, marketType: Str = ..., subType: Str = ..., symbolWithActiveStatus: bool = ..., symbolWithUnknownStatus: bool = ...): # -> list[Any]:
        ...
    
    def filter_by_array(self, objects, key: IndexType, values=..., indexed=...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def fetch2(self, path, api: Any = ..., method=..., params=..., headers: Any = ..., body: Any = ..., config=...): # -> None:
        ...
    
    def request(self, path, api: Any = ..., method=..., params=..., headers: Any = ..., body: Any = ..., config=...): # -> None:
        ...
    
    def load_accounts(self, reload=..., params=...):
        ...
    
    def build_ohlcvc(self, trades: List[Trade], timeframe: str = ..., since: float = ..., limit: float = ...): # -> list[Any]:
        ...
    
    def parse_trading_view_ohlcv(self, ohlcvs, market=..., timeframe=..., since: Int = ..., limit: Int = ...): # -> list[Any] | List[object]:
        ...
    
    def edit_limit_buy_order(self, id: str, symbol: str, amount: float, price: Num = ..., params=...):
        ...
    
    def edit_limit_sell_order(self, id: str, symbol: str, amount: float, price: Num = ..., params=...):
        ...
    
    def edit_limit_order(self, id: str, symbol: str, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def edit_order(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: Num = ..., price: Num = ..., params=...):
        ...
    
    def edit_order_ws(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: Num = ..., price: Num = ..., params=...):
        ...
    
    def fetch_position(self, symbol: str, params=...):
        ...
    
    def fetch_position_ws(self, symbol: str, params=...):
        ...
    
    def watch_position(self, symbol: Str = ..., params=...):
        ...
    
    def watch_positions(self, symbols: Strings = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_position_for_symbols(self, symbols: Strings = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_positions_for_symbol(self, symbol: str, params=...):
        """
        fetches all open positions for specific symbol, unlike fetchPositions(which is designed to work with multiple symbols) so self method might be preffered for one-market position, because of less rate-limit consumption and speed
        :param str symbol: unified market symbol
        :param dict params: extra parameters specific to the endpoint
        :returns dict[]: a list of `position structure <https://docs.ccxt.com/#/?id=position-structure>` with maximum 3 items - possible one position for "one-way" mode, and possible two positions(long & short) for "two-way"(a.k.a. hedge) mode
        """
        ...
    
    def fetch_positions_for_symbol_ws(self, symbol: str, params=...):
        """
        fetches all open positions for specific symbol, unlike fetchPositions(which is designed to work with multiple symbols) so self method might be preffered for one-market position, because of less rate-limit consumption and speed
        :param str symbol: unified market symbol
        :param dict params: extra parameters specific to the endpoint
        :returns dict[]: a list of `position structure <https://docs.ccxt.com/#/?id=position-structure>` with maximum 3 items - possible one position for "one-way" mode, and possible two positions(long & short) for "two-way"(a.k.a. hedge) mode
        """
        ...
    
    def fetch_positions(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_positions_ws(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_positions_risk(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_bids_asks(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_borrow_interest(self, code: Str = ..., symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_ledger(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_ledger_entry(self, id: str, code: Str = ..., params=...):
        ...
    
    def parse_bid_ask(self, bidask, priceKey: IndexType = ..., amountKey: IndexType = ..., countOrIdKey: IndexType = ...): # -> list[Any | None]:
        ...
    
    def safe_currency(self, currencyId: Str, currency: Currency = ...): # -> CurrencyInterface | OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def safe_market(self, marketId: Str = ..., market: Market = ..., delimiter: Str = ..., marketType: Str = ...): # -> OrderedDict[Any, Any] | dict[Any, Any] | MarketInterface:
        ...
    
    def market_or_null(self, symbol: str):
        ...
    
    def check_required_credentials(self, error=...): # -> bool:
        """
 @ignore
        :param boolean error: raise an error that a credential is required if True
        :returns boolean: True if all required credentials have been set, otherwise False or an error is thrown is param error=true
        """
        ...
    
    def oath(self): # -> str:
        ...
    
    def fetch_balance(self, params=...):
        ...
    
    def fetch_balance_ws(self, params=...):
        ...
    
    def parse_balance(self, response):
        ...
    
    def watch_balance(self, params=...):
        ...
    
    def fetch_partial_balance(self, part, params=...):
        ...
    
    def fetch_free_balance(self, params=...):
        ...
    
    def fetch_used_balance(self, params=...):
        ...
    
    def fetch_total_balance(self, params=...):
        ...
    
    def fetch_status(self, params=...):
        ...
    
    def fetch_transaction_fee(self, code: str, params=...):
        ...
    
    def fetch_transaction_fees(self, codes: Strings = ..., params=...):
        ...
    
    def fetch_deposit_withdraw_fees(self, codes: Strings = ..., params=...):
        ...
    
    def fetch_deposit_withdraw_fee(self, code: str, params=...):
        ...
    
    def get_supported_mapping(self, key, mapping=...):
        ...
    
    def fetch_cross_borrow_rate(self, code: str, params=...):
        ...
    
    def fetch_isolated_borrow_rate(self, symbol: str, params=...):
        ...
    
    def handle_option_and_params(self, params: object, methodName: str, optionName: str, defaultValue=...): # -> list[Any]:
        ...
    
    def handle_option_and_params_2(self, params: object, methodName1: str, optionName1: str, optionName2: str, defaultValue=...): # -> list[Any]:
        ...
    
    def handle_option(self, methodName: str, optionName: str, defaultValue=...): # -> None:
        ...
    
    def handle_market_type_and_params(self, methodName: str, market: Market = ..., params=..., defaultValue=...): # -> list[Any]:
        """
 @ignore
 @param methodName the method calling handleMarketTypeAndParams
        :param Market market:
        :param dict params:
        :param str [params.type]: type assigned by user
        :param str [params.defaultType]: same.type
        :param str [defaultValue]: assigned programatically in the method calling handleMarketTypeAndParams
        :returns [str, dict]: the market type and params with type and defaultType omitted
        """
        ...
    
    def handle_sub_type_and_params(self, methodName: str, market=..., params=..., defaultValue=...): # -> list[Any]:
        ...
    
    def handle_margin_mode_and_params(self, methodName: str, params=..., defaultValue=...): # -> list[Any]:
        """
 @ignore
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Array: the marginMode in lowercase by params["marginMode"], params["defaultMarginMode"] self.options["marginMode"] or self.options["defaultMarginMode"]
        """
        ...
    
    def throw_exactly_matched_exception(self, exact, string, message): # -> None:
        ...
    
    def throw_broadly_matched_exception(self, broad, string, message): # -> None:
        ...
    
    def find_broadly_matched_key(self, broad, string): # -> None:
        ...
    
    def handle_errors(self, statusCode: int, statusText: str, url: str, method: str, responseHeaders: dict, responseBody: str, response, requestHeaders, requestBody): # -> None:
        ...
    
    def calculate_rate_limiter_cost(self, api, method, path, params, config=...): # -> None:
        ...
    
    def fetch_ticker(self, symbol: str, params=...):
        ...
    
    def fetch_mark_price(self, symbol: str, params=...):
        ...
    
    def fetch_ticker_ws(self, symbol: str, params=...):
        ...
    
    def watch_ticker(self, symbol: str, params=...):
        ...
    
    def fetch_tickers(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_mark_prices(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_tickers_ws(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_order_books(self, symbols: Strings = ..., limit: Int = ..., params=...):
        ...
    
    def watch_bids_asks(self, symbols: Strings = ..., params=...):
        ...
    
    def watch_tickers(self, symbols: Strings = ..., params=...):
        ...
    
    def un_watch_tickers(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_order(self, id: str, symbol: Str = ..., params=...):
        ...
    
    def fetch_order_ws(self, id: str, symbol: Str = ..., params=...):
        ...
    
    def fetch_order_status(self, id: str, symbol: Str = ..., params=...):
        ...
    
    def fetch_unified_order(self, order, params=...):
        ...
    
    def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_convert_trade(self, id: str, fromCode: str, toCode: str, amount: Num = ..., params=...):
        ...
    
    def fetch_convert_trade(self, id: str, code: Str = ..., params=...):
        ...
    
    def fetch_convert_trade_history(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_position_mode(self, symbol: Str = ..., params=...):
        ...
    
    def create_trailing_amount_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., trailingAmount: Num = ..., trailingTriggerPrice: Num = ..., params=...):
        """
        create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency, or number of contracts
        :param float [price]: the price for the order to be filled at, in units of the quote currency, ignored in market orders
        :param float trailingAmount: the quote amount to trail away from the current market price
        :param float [trailingTriggerPrice]: the price to activate a trailing order, default uses the price argument
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_trailing_amount_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., trailingAmount: Num = ..., trailingTriggerPrice: Num = ..., params=...):
        """
        create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency, or number of contracts
        :param float [price]: the price for the order to be filled at, in units of the quote currency, ignored in market orders
        :param float trailingAmount: the quote amount to trail away from the current market price
        :param float [trailingTriggerPrice]: the price to activate a trailing order, default uses the price argument
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_trailing_percent_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., trailingPercent: Num = ..., trailingTriggerPrice: Num = ..., params=...):
        """
        create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency, or number of contracts
        :param float [price]: the price for the order to be filled at, in units of the quote currency, ignored in market orders
        :param float trailingPercent: the percent to trail away from the current market price
        :param float [trailingTriggerPrice]: the price to activate a trailing order, default uses the price argument
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_trailing_percent_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., trailingPercent: Num = ..., trailingTriggerPrice: Num = ..., params=...):
        """
        create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency, or number of contracts
        :param float [price]: the price for the order to be filled at, in units of the quote currency, ignored in market orders
        :param float trailingPercent: the percent to trail away from the current market price
        :param float [trailingTriggerPrice]: the price to activate a trailing order, default uses the price argument
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_market_order_with_cost(self, symbol: str, side: OrderSide, cost: float, params=...):
        """
        create a market order by providing the symbol, side and cost
        :param str symbol: unified symbol of the market to create an order in
        :param str side: 'buy' or 'sell'
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_market_buy_order_with_cost(self, symbol: str, cost: float, params=...):
        """
        create a market buy order by providing the symbol and cost
        :param str symbol: unified symbol of the market to create an order in
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_market_sell_order_with_cost(self, symbol: str, cost: float, params=...):
        """
        create a market sell order by providing the symbol and cost
        :param str symbol: unified symbol of the market to create an order in
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_market_order_with_cost_ws(self, symbol: str, side: OrderSide, cost: float, params=...):
        """
        create a market order by providing the symbol, side and cost
        :param str symbol: unified symbol of the market to create an order in
        :param str side: 'buy' or 'sell'
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_trigger_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., triggerPrice: Num = ..., params=...):
        """
        create a trigger stop order(type 1)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float triggerPrice: the price to trigger the stop order, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_trigger_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., triggerPrice: Num = ..., params=...):
        """
        create a trigger stop order(type 1)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float triggerPrice: the price to trigger the stop order, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_stop_loss_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., stopLossPrice: Num = ..., params=...):
        """
        create a trigger stop loss order(type 2)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float stopLossPrice: the price to trigger the stop loss order, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_stop_loss_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., stopLossPrice: Num = ..., params=...):
        """
        create a trigger stop loss order(type 2)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float stopLossPrice: the price to trigger the stop loss order, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_take_profit_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., takeProfitPrice: Num = ..., params=...):
        """
        create a trigger take profit order(type 2)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float takeProfitPrice: the price to trigger the take profit order, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_take_profit_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., takeProfitPrice: Num = ..., params=...):
        """
        create a trigger take profit order(type 2)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float takeProfitPrice: the price to trigger the take profit order, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_order_with_take_profit_and_stop_loss(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., takeProfit: Num = ..., stopLoss: Num = ..., params=...):
        """
        create an order with a stop loss or take profit attached(type 3)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float [takeProfit]: the take profit price, in units of the quote currency
        :param float [stopLoss]: the stop loss price, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.takeProfitType]: *not available on all exchanges* 'limit' or 'market'
        :param str [params.stopLossType]: *not available on all exchanges* 'limit' or 'market'
        :param str [params.takeProfitPriceType]: *not available on all exchanges* 'last', 'mark' or 'index'
        :param str [params.stopLossPriceType]: *not available on all exchanges* 'last', 'mark' or 'index'
        :param float [params.takeProfitLimitPrice]: *not available on all exchanges* limit price for a limit take profit order
        :param float [params.stopLossLimitPrice]: *not available on all exchanges* stop loss for a limit stop loss order
        :param float [params.takeProfitAmount]: *not available on all exchanges* the amount for a take profit
        :param float [params.stopLossAmount]: *not available on all exchanges* the amount for a stop loss
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def set_take_profit_and_stop_loss_params(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., takeProfit: Num = ..., stopLoss: Num = ..., params=...): # -> dict[Any, Any]:
        ...
    
    def create_order_with_take_profit_and_stop_loss_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., takeProfit: Num = ..., stopLoss: Num = ..., params=...):
        """
        create an order with a stop loss or take profit attached(type 3)
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency or the number of contracts
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param float [takeProfit]: the take profit price, in units of the quote currency
        :param float [stopLoss]: the stop loss price, in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.takeProfitType]: *not available on all exchanges* 'limit' or 'market'
        :param str [params.stopLossType]: *not available on all exchanges* 'limit' or 'market'
        :param str [params.takeProfitPriceType]: *not available on all exchanges* 'last', 'mark' or 'index'
        :param str [params.stopLossPriceType]: *not available on all exchanges* 'last', 'mark' or 'index'
        :param float [params.takeProfitLimitPrice]: *not available on all exchanges* limit price for a limit take profit order
        :param float [params.stopLossLimitPrice]: *not available on all exchanges* stop loss for a limit stop loss order
        :param float [params.takeProfitAmount]: *not available on all exchanges* the amount for a take profit
        :param float [params.stopLossAmount]: *not available on all exchanges* the amount for a stop loss
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_orders(self, orders: List[OrderRequest], params=...):
        ...
    
    def edit_orders(self, orders: List[OrderRequest], params=...):
        ...
    
    def create_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def cancel_order(self, id: str, symbol: Str = ..., params=...):
        ...
    
    def cancel_order_ws(self, id: str, symbol: Str = ..., params=...):
        ...
    
    def cancel_orders(self, ids: List[str], symbol: Str = ..., params=...):
        ...
    
    def cancel_orders_ws(self, ids: List[str], symbol: Str = ..., params=...):
        ...
    
    def cancel_all_orders(self, symbol: Str = ..., params=...):
        ...
    
    def cancel_all_orders_after(self, timeout: Int, params=...):
        ...
    
    def cancel_orders_for_symbols(self, orders: List[CancellationRequest], params=...):
        ...
    
    def cancel_all_orders_ws(self, symbol: Str = ..., params=...):
        ...
    
    def cancel_unified_order(self, order: Order, params=...):
        ...
    
    def fetch_orders(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_orders_ws(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_order_trades(self, id: str, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_orders(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_open_orders(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_open_orders_ws(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_closed_orders(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_canceled_and_closed_orders(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_closed_orders_ws(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_my_trades(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_my_liquidations(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_liquidations(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_my_trades_ws(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def watch_my_trades(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_greeks(self, symbol: str, params=...):
        ...
    
    def fetch_all_greeks(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_option_chain(self, code: str, params=...):
        ...
    
    def fetch_option(self, symbol: str, params=...):
        ...
    
    def fetch_convert_quote(self, fromCode: str, toCode: str, amount: Num = ..., params=...):
        ...
    
    def fetch_deposits_withdrawals(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        fetch history of deposits and withdrawals
        :param str [code]: unified currency code for the currency of the deposit/withdrawals, default is None
        :param int [since]: timestamp in ms of the earliest deposit/withdrawal, default is None
        :param int [limit]: max number of deposit/withdrawals to return, default is None
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a list of `transaction structures <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        ...
    
    def fetch_deposits(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_withdrawals(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_deposits_ws(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_withdrawals_ws(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_funding_rate_history(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def fetch_funding_history(self, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        ...
    
    def close_position(self, symbol: str, side: OrderSide = ..., params=...):
        ...
    
    def close_all_positions(self, params=...):
        ...
    
    def fetch_l3_order_book(self, symbol: str, limit: Int = ..., params=...):
        ...
    
    def parse_last_price(self, price, market: Market = ...):
        ...
    
    def fetch_deposit_address(self, code: str, params=...):
        ...
    
    def account(self) -> BalanceAccount:
        ...
    
    def common_currency_code(self, code: str): # -> str | None:
        ...
    
    def currency(self, code: str):
        ...
    
    def market(self, symbol: str):
        ...
    
    def create_expired_option_market(self, symbol: str):
        ...
    
    def is_leveraged_currency(self, currencyCode, checkBaseCoin: Bool = ..., existingCurrencies: dict = ...): # -> bool:
        ...
    
    def handle_withdraw_tag_and_params(self, tag, params): # -> list[Any]:
        ...
    
    def create_limit_order(self, symbol: str, side: OrderSide, amount: float, price: float, params=...):
        ...
    
    def create_limit_order_ws(self, symbol: str, side: OrderSide, amount: float, price: float, params=...):
        ...
    
    def create_market_order(self, symbol: str, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_market_order_ws(self, symbol: str, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_limit_buy_order(self, symbol: str, amount: float, price: float, params=...):
        ...
    
    def create_limit_buy_order_ws(self, symbol: str, amount: float, price: float, params=...):
        ...
    
    def create_limit_sell_order(self, symbol: str, amount: float, price: float, params=...):
        ...
    
    def create_limit_sell_order_ws(self, symbol: str, amount: float, price: float, params=...):
        ...
    
    def create_market_buy_order(self, symbol: str, amount: float, params=...):
        ...
    
    def create_market_buy_order_ws(self, symbol: str, amount: float, params=...):
        ...
    
    def create_market_sell_order(self, symbol: str, amount: float, params=...):
        ...
    
    def create_market_sell_order_ws(self, symbol: str, amount: float, params=...):
        ...
    
    def cost_to_precision(self, symbol: str, cost): # -> None:
        ...
    
    def price_to_precision(self, symbol: str, price): # -> None:
        ...
    
    def amount_to_precision(self, symbol: str, amount): # -> None:
        ...
    
    def fee_to_precision(self, symbol: str, fee): # -> None:
        ...
    
    def currency_to_precision(self, code: str, fee, networkCode=...): # -> str | None:
        ...
    
    def force_string(self, value): # -> str | None:
        ...
    
    def is_tick_precision(self): # -> bool:
        ...
    
    def is_decimal_precision(self): # -> bool:
        ...
    
    def is_significant_precision(self): # -> bool:
        ...
    
    def safe_number(self, obj, key: IndexType, defaultNumber: Num = ...): # -> None:
        ...
    
    def safe_number_n(self, obj: object, arr: List[IndexType], defaultNumber: Num = ...): # -> None:
        ...
    
    def parse_precision(self, precision: str): # -> LiteralString | Literal['1']:
        """
 @ignore
        :param str precision: The number of digits to the right of the decimal
        :returns str: a string number equal to 1e-precision
        """
        ...
    
    def integer_precision_to_amount(self, precision: Str): # -> LiteralString | Literal['1'] | None:
        """
 @ignore
        handles positive & negative numbers too. parsePrecision() does not handle negative numbers, but self method handles
        :param str precision: The number of digits to the right of the decimal
        :returns str: a string number equal to 1e-precision
        """
        ...
    
    def load_time_difference(self, params=...):
        ...
    
    def implode_hostname(self, url: str):
        ...
    
    def fetch_market_leverage_tiers(self, symbol: str, params=...):
        ...
    
    def create_post_only_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_post_only_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_reduce_only_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_reduce_only_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., params=...):
        ...
    
    def create_stop_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., triggerPrice: Num = ..., params=...):
        ...
    
    def create_stop_order_ws(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = ..., triggerPrice: Num = ..., params=...):
        ...
    
    def create_stop_limit_order(self, symbol: str, side: OrderSide, amount: float, price: float, triggerPrice: float, params=...):
        ...
    
    def create_stop_limit_order_ws(self, symbol: str, side: OrderSide, amount: float, price: float, triggerPrice: float, params=...):
        ...
    
    def create_stop_market_order(self, symbol: str, side: OrderSide, amount: float, triggerPrice: float, params=...):
        ...
    
    def create_stop_market_order_ws(self, symbol: str, side: OrderSide, amount: float, triggerPrice: float, params=...):
        ...
    
    def safe_currency_code(self, currencyId: Str, currency: Currency = ...):
        ...
    
    def filter_by_symbol_since_limit(self, array, symbol: Str = ..., since: Int = ..., limit: Int = ..., tail=...): # -> list[Any] | List[object]:
        ...
    
    def filter_by_currency_since_limit(self, array, code=..., since: Int = ..., limit: Int = ..., tail=...): # -> list[Any] | List[object]:
        ...
    
    def filter_by_symbols_since_limit(self, array, symbols: List[str] = ..., since: Int = ..., limit: Int = ..., tail=...): # -> list[Any] | List[object]:
        ...
    
    def parse_last_prices(self, pricesData, symbols: List[str] = ..., params=...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_tickers(self, tickers, symbols: Strings = ..., params=...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_deposit_addresses(self, addresses, codes: Strings = ..., indexed=..., params=...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_borrow_interests(self, response, market: Market = ...): # -> list[Any]:
        ...
    
    def parse_borrow_rate(self, info, currency: Currency = ...):
        ...
    
    def parse_borrow_rate_history(self, response, code: Str, since: Int, limit: Int): # -> list[Any] | List[object]:
        ...
    
    def parse_isolated_borrow_rates(self, info: Any): # -> dict[Any, Any]:
        ...
    
    def parse_funding_rate_histories(self, response, market=..., since: Int = ..., limit: Int = ...): # -> list[Any] | List[object]:
        ...
    
    def safe_symbol(self, marketId: Str, market: Market = ..., delimiter: Str = ..., marketType: Str = ...):
        ...
    
    def parse_funding_rate(self, contract: str, market: Market = ...):
        ...
    
    def parse_funding_rates(self, response, symbols: Strings = ...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_long_short_ratio(self, info: dict, market: Market = ...):
        ...
    
    def parse_long_short_ratio_history(self, response, market=..., since: Int = ..., limit: Int = ...): # -> list[Any] | List[object]:
        ...
    
    def handle_trigger_prices_and_params(self, symbol, params, omitParams=...): # -> list[Any]:
        ...
    
    def handle_trigger_direction_and_params(self, params, exchangeSpecificKey: Str = ..., allowEmpty: Bool = ...): # -> list[Any]:
        """
 @ignore
        :returns [str, dict]: the trigger-direction value and omited params
        """
        ...
    
    def handle_trigger_and_params(self, params): # -> list[Any]:
        ...
    
    def is_trigger_order(self, params): # -> list[Any]:
        ...
    
    def is_post_only(self, isMarketOrder: bool, exchangeSpecificParam, params=...): # -> bool:
        """
 @ignore
        :param str type: Order type
        :param boolean exchangeSpecificParam: exchange specific postOnly
        :param dict [params]: exchange specific params
        :returns boolean: True if a post only order, False otherwise
        """
        ...
    
    def handle_post_only(self, isMarketOrder: bool, exchangeSpecificPostOnlyOption: bool, params: Any = ...): # -> list[Any]:
        """
 @ignore
        :param str type: Order type
        :param boolean exchangeSpecificBoolean: exchange specific postOnly
        :param dict [params]: exchange specific params
        :returns Array:
        """
        ...
    
    def fetch_last_prices(self, symbols: Strings = ..., params=...):
        ...
    
    def fetch_trading_fees(self, params=...):
        ...
    
    def fetch_trading_fees_ws(self, params=...):
        ...
    
    def fetch_trading_fee(self, symbol: str, params=...):
        ...
    
    def fetch_convert_currencies(self, params=...):
        ...
    
    def parse_open_interest(self, interest, market: Market = ...):
        ...
    
    def parse_open_interests(self, response, symbols: Strings = ...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_open_interests_history(self, response, market=..., since: Int = ..., limit: Int = ...): # -> list[Any] | List[object]:
        ...
    
    def fetch_funding_rate(self, symbol: str, params=...):
        ...
    
    def fetch_funding_interval(self, symbol: str, params=...):
        ...
    
    def fetch_mark_ohlcv(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        fetches historical mark price candlestick data containing the open, high, low, and close price of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns float[][]: A list of candles ordered, open, high, low, close, None
        """
        ...
    
    def fetch_index_ohlcv(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        fetches historical index price candlestick data containing the open, high, low, and close price of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
 @returns {} A list of candles ordered, open, high, low, close, None
        """
        ...
    
    def fetch_premium_index_ohlcv(self, symbol: str, timeframe: str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns float[][]: A list of candles ordered, open, high, low, close, None
        """
        ...
    
    def handle_time_in_force(self, params=...): # -> str | None:
        """
 @ignore
 Must add timeInForce to self.options to use self method
        :returns str: returns the exchange specific value for timeInForce
        """
        ...
    
    def convert_type_to_account(self, account):
        """
 @ignore
 Must add accountsByType to self.options to use self method
        :param str account: key for account name in self.options['accountsByType']
        :returns: the exchange specific account name or the isolated margin id for transfers
        """
        ...
    
    def check_required_argument(self, methodName: str, argument, argumentName, options=...): # -> None:
        """
 @ignore
        :param str methodName: the name of the method that the argument is being checked for
        :param str argument: the argument's actual value provided
        :param str argumentName: the name of the argument being checked(for logging purposes)
        :param str[] options: a list of options that the argument can be
        :returns None:
        """
        ...
    
    def check_required_margin_argument(self, methodName: str, symbol: Str, marginMode: str): # -> None:
        """
 @ignore
        :param str symbol: unified symbol of the market
        :param str methodName: name of the method that requires a symbol
        :param str marginMode: is either 'isolated' or 'cross'
        """
        ...
    
    def parse_deposit_withdraw_fees(self, response, codes: Strings = ..., currencyIdKey=...): # -> dict[Any, Any]:
        """
 @ignore
        :param object[]|dict response: unparsed response from the exchange
        :param str[]|None codes: the unified currency codes to fetch transactions fees for, returns all currencies when None
        :param str currencyIdKey: *should only be None when response is a dictionary* the object key that corresponds to the currency id
        :returns dict: objects with withdraw and deposit fees, indexed by currency codes
        """
        ...
    
    def parse_deposit_withdraw_fee(self, fee, currency: Currency = ...):
        ...
    
    def deposit_withdraw_fee(self, info): # -> dict[str, Any]:
        ...
    
    def assign_default_deposit_withdraw_fees(self, fee, currency=...):
        """
 @ignore
        Takes a depositWithdrawFee structure and assigns the default values for withdraw and deposit
        :param dict fee: A deposit withdraw fee structure
        :param dict currency: A currency structure, the response from self.currency()
        :returns dict: A deposit withdraw fee structure
        """
        ...
    
    def parse_income(self, info, market: Market = ...):
        ...
    
    def parse_incomes(self, incomes, market=..., since: Int = ..., limit: Int = ...): # -> list[Any] | List[object]:
        """
 @ignore
        parses funding fee info from exchange response
        :param dict[] incomes: each item describes once instance of currency being received or paid
        :param dict market: ccxt market
        :param int [since]: when defined, the response items are filtered to only include items after self timestamp
        :param int [limit]: limits the number of items in the response
        :returns dict[]: an array of `funding history structures <https://docs.ccxt.com/#/?id=funding-history-structure>`
        """
        ...
    
    def get_market_from_symbols(self, symbols: Strings = ...): # -> None:
        ...
    
    def parse_ws_ohlcvs(self, ohlcvs: List[object], market: Any = ..., timeframe: str = ..., since: Int = ..., limit: Int = ...): # -> list[Any]:
        ...
    
    def fetch_transactions(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
 @deprecated
        *DEPRECATED* use fetchDepositsWithdrawals instead
        :param str code: unified currency code for the currency of the deposit/withdrawals, default is None
        :param int [since]: timestamp in ms of the earliest deposit/withdrawal, default is None
        :param int [limit]: max number of deposit/withdrawals to return, default is None
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a list of `transaction structures <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        ...
    
    def filter_by_array_positions(self, objects, key: IndexType, values=..., indexed=...): # -> dict[Any, Any] | list[Any]:
        """
 @ignore
        Typed wrapper for filterByArray that returns a list of positions
        """
        ...
    
    def filter_by_array_tickers(self, objects, key: IndexType, values=..., indexed=...): # -> dict[Any, Any] | list[Any]:
        """
 @ignore
        Typed wrapper for filterByArray that returns a dictionary of tickers
        """
        ...
    
    def create_ohlcv_object(self, symbol: str, timeframe: str, data): # -> dict[Any, Any]:
        ...
    
    def handle_max_entries_per_request_and_params(self, method: str, maxEntriesPerRequest: Int = ..., params=...): # -> list[Any]:
        ...
    
    def fetch_paginated_call_dynamic(self, method: str, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=..., maxEntriesPerRequest: Int = ..., removeRepeated=...):
        ...
    
    def safe_deterministic_call(self, method: str, symbol: Str = ..., since: Int = ..., limit: Int = ..., timeframe: Str = ..., params=...): # -> Any | list[Any]:
        ...
    
    def fetch_paginated_call_deterministic(self, method: str, symbol: Str = ..., since: Int = ..., limit: Int = ..., timeframe: Str = ..., params=..., maxEntriesPerRequest=...): # -> list[Any] | List[object]:
        ...
    
    def fetch_paginated_call_cursor(self, method: str, symbol: Str = ..., since=..., limit=..., params=..., cursorReceived=..., cursorSent=..., cursorIncrement=..., maxEntriesPerRequest=...):
        ...
    
    def fetch_paginated_call_incremental(self, method: str, symbol: Str = ..., since=..., limit=..., params=..., pageKey=..., maxEntriesPerRequest=...): # -> list[Any] | List[object]:
        ...
    
    def sort_cursor_paginated_result(self, result): # -> list[Any]:
        ...
    
    def remove_repeated_elements_from_array(self, input, fallbackToTimestamp: bool = ...): # -> list[Any]:
        ...
    
    def remove_repeated_trades_from_array(self, input): # -> list[Any]:
        ...
    
    def remove_keys_from_dict(self, dict: dict, removeKeys: List[str]): # -> dict[Any, Any]:
        ...
    
    def handle_until_option(self, key: str, request, params, multiplier=...): # -> list[Any]:
        ...
    
    def safe_open_interest(self, interest: dict, market: Market = ...): # -> OrderedDict[Any, Any] | dict[Any, Any]:
        ...
    
    def parse_liquidation(self, liquidation, market: Market = ...):
        ...
    
    def parse_liquidations(self, liquidations: List[dict], market: Market = ..., since: Int = ..., limit: Int = ...): # -> list[Any] | List[object]:
        """
 @ignore
        parses liquidation info from the exchange response
        :param dict[] liquidations: each item describes an instance of a liquidation event
        :param dict market: ccxt market
        :param int [since]: when defined, the response items are filtered to only include items after self timestamp
        :param int [limit]: limits the number of items in the response
        :returns dict[]: an array of `liquidation structures <https://docs.ccxt.com/#/?id=liquidation-structure>`
        """
        ...
    
    def parse_greeks(self, greeks: dict, market: Market = ...):
        ...
    
    def parse_all_greeks(self, greeks, symbols: Strings = ..., params=...): # -> dict[Any, Any] | list[Any]:
        ...
    
    def parse_option(self, chain: dict, currency: Currency = ..., market: Market = ...):
        ...
    
    def parse_option_chain(self, response: List[object], currencyKey: Str = ..., symbolKey: Str = ...): # -> dict[Any, Any]:
        ...
    
    def parse_margin_modes(self, response: List[object], symbols: List[str] = ..., symbolKey: Str = ..., marketType: MarketType = ...): # -> dict[Any, Any]:
        ...
    
    def parse_margin_mode(self, marginMode: dict, market: Market = ...):
        ...
    
    def parse_leverages(self, response: List[object], symbols: List[str] = ..., symbolKey: Str = ..., marketType: MarketType = ...): # -> dict[Any, Any]:
        ...
    
    def parse_leverage(self, leverage: dict, market: Market = ...):
        ...
    
    def parse_conversions(self, conversions: List[Any], code: Str = ..., fromCurrencyKey: Str = ..., toCurrencyKey: Str = ..., since: Int = ..., limit: Int = ..., params=...): # -> list[Any] | List[object]:
        ...
    
    def parse_conversion(self, conversion: dict, fromCurrency: Currency = ..., toCurrency: Currency = ...):
        ...
    
    def convert_expire_date(self, date: str): # -> str:
        ...
    
    def convert_expire_date_to_market_id_date(self, date: str): # -> str:
        ...
    
    def convert_market_id_expire_date(self, date: str): # -> str:
        ...
    
    def fetch_position_history(self, symbol: str, since: Int = ..., limit: Int = ..., params=...):
        """
        fetches the history of margin added or reduced from contract isolated positions
        :param str [symbol]: unified market symbol
        :param int [since]: timestamp in ms of the position
        :param int [limit]: the maximum amount of candles to fetch, default=1000
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns dict[]: a list of `position structures <https://docs.ccxt.com/#/?id=position-structure>`
        """
        ...
    
    def fetch_positions_history(self, symbols: Strings = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        fetches the history of margin added or reduced from contract isolated positions
        :param str [symbol]: unified market symbol
        :param int [since]: timestamp in ms of the position
        :param int [limit]: the maximum amount of candles to fetch, default=1000
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns dict[]: a list of `position structures <https://docs.ccxt.com/#/?id=position-structure>`
        """
        ...
    
    def parse_margin_modification(self, data: dict, market: Market = ...):
        ...
    
    def parse_margin_modifications(self, response: List[object], symbols: Strings = ..., symbolKey: Str = ..., marketType: MarketType = ...): # -> list[Any]:
        ...
    
    def fetch_transfer(self, id: str, code: Str = ..., params=...):
        """
        fetches a transfer
        :param str id: transfer id
        :param [str] code: unified currency code
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns dict: a `transfer structure <https://docs.ccxt.com/#/?id=transfer-structure>`
        """
        ...
    
    def fetch_transfers(self, code: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        fetches a transfer
        :param str id: transfer id
        :param int [since]: timestamp in ms of the earliest transfer to fetch
        :param int [limit]: the maximum amount of transfers to fetch
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns dict: a `transfer structure <https://docs.ccxt.com/#/?id=transfer-structure>`
        """
        ...
    
    def un_watch_ohlcv(self, symbol: str, timeframe: str = ..., params=...):
        """
        watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        ...
    
    def watch_mark_price(self, symbol: str, params=...):
        """
        watches a mark price for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        ...
    
    def watch_mark_prices(self, symbols: Strings = ..., params=...):
        """
        watches the mark price for all markets
        :param str[] symbols: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        ...
    
    def withdraw_ws(self, code: str, amount: float, address: str, tag: Str = ..., params=...):
        """
        make a withdrawal
        :param str code: unified currency code
        :param float amount: the amount to withdraw
        :param str address: the address to withdraw to
        :param str tag:
        :param dict [params]: extra parameters specific to the bitvavo api endpoint
        :returns dict: a `transaction structure <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        ...
    
    def un_watch_my_trades(self, symbol: Str = ..., params=...):
        """
        unWatches information on multiple trades made by the user
        :param str symbol: unified market symbol of the market orders were made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def create_orders_ws(self, orders: List[OrderRequest], params=...):
        """
        create a list of trade orders
        :param Array orders: list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ...
    
    def fetch_orders_by_status_ws(self, status: str, symbol: Str = ..., since: Int = ..., limit: Int = ..., params=...):
        """
        watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        ...
    
    def un_watch_bids_asks(self, symbols: Strings = ..., params=...):
        """
        unWatches best bid & ask for symbols
        :param str[] symbols: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        ...
    
    def clean_unsubscription(self, client, subHash: str, unsubHash: str, subHashIsPrefix=...): # -> None:
        ...
    
    def clean_cache(self, subscription: dict): # -> None:
        ...
    


